<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>sql on Dan Goldin</title><link>/tags/sql/</link><description>Recent content in sql on Dan Goldin</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 20 Feb 2018 00:00:00 +0000</lastBuildDate><atom:link href="/tags/sql/index.xml" rel="self" type="application/rss+xml"/><item><title>Analyzing AWS ELB logs</title><link>/2018/02/20/analyzing-aws-elb-logs/</link><pubDate>Tue, 20 Feb 2018 00:00:00 +0000</pubDate><guid>/2018/02/20/analyzing-aws-elb-logs/</guid><description>Logging HTTP requests should be enabled for every application you run. When things go wrong, and they will, it’s often the first step to understand the problem. Unfortunately, logging isn’t always top of mind and is often forgotten. Luckily, if you use the Elastic Load Balancer (ELB) functionality within AWS you’re able to set up ELB logs that track every request and write it to an S3 bucket. The documentation is up on the Amazon site but there’s a surprising amount of information that’s hidden away in the logs.</description></item><item><title>Analyzing IMDB data: Step 1 - Cleaning and QA</title><link>/2016/05/21/analyzing-imdb-data-step-1-cleaning-and-qa/</link><pubDate>Sat, 21 May 2016 00:00:00 +0000</pubDate><guid>/2016/05/21/analyzing-imdb-data-step-1-cleaning-and-qa/</guid><description>In 2012 I did a simple analysis of IMDB to analyze the change in actor and actresses’s ages over time. At that point I limited the analysis to the top 50 movies each decade and hacked together a quick script to crawl and scrape the IMDB analysis. A couple of weeks ago I came across a great post by CuriousGnu that did a similar analysis across a larger set of movies but limited to movies since 2000.</description></item><item><title>Identifying unused database tables</title><link>/2016/05/11/identifying-unused-database-tables/</link><pubDate>Wed, 11 May 2016 00:00:00 +0000</pubDate><guid>/2016/05/11/identifying-unused-database-tables/</guid><description>When writing code it’s very easy to accumulate deprecated database tables that end up as zombies - they’re still around and may even be populated and used by a variety of side scripts but if they disappeared and the dependent code was removed nothing would be different. In fact you’d have a smaller code base, a smaller database, and would hopefully improve everyone’s productivity a tiny bit.
Dealing with the tables are are still being populated and read requires a bit of investigative work and knowledge of the product since there’s no simple way of identifying them.</description></item><item><title>The MySQL enum type</title><link>/2016/03/10/the-mysql-enum-type/</link><pubDate>Thu, 10 Mar 2016 00:00:00 +0000</pubDate><guid>/2016/03/10/the-mysql-enum-type/</guid><description>The MySQL enum field provides a nice compromise - the space efficiency of using an integer, the human readability of text, and basic type safety. Yet I had this vague recollection of reading something that made it seem enums carried a ton of risks when changing the column definition so wanted to see if I could “break” it. Turns out it’s a lot more resilient than I thought. I went through a series of combinations - ranging from changing the order of the enums in the definition to trying to insert values that didn’t exist but in every case it handled it as expected.</description></item><item><title>More MySQL fun</title><link>/2015/11/21/more-mysql-fun/</link><pubDate>Sat, 21 Nov 2015 00:00:00 +0000</pubDate><guid>/2015/11/21/more-mysql-fun/</guid><description>I had a bit of fun with MySQL earlier this week when trying to explain a non obvious “group by” behavior. It’s fairly common to want to manipulate a field in order to transform it into something more useful. The difficulty arises when you want to keep the original name. Below is some SQL code that highlights the odd behavior.
drop table if exists dan_test; create table dan_test ( id int not null, id2 int not null ); insert into dan_test (id, id2) values (1,1), (2,2), (3,3); select * from dan_test; select id, case when id = 1 then 2 else id end as id, id2 from dan_test; select id, sum(id2) from dan_test group by id; select case when id = 1 then 2 else id end as id, sum(id2) from dan_test group by id; select case when id = 1 then 2 else id end as new_id, sum(id2) from dan_test group by new_id; With the second to last query it’s not obvious which id field the group by is referring to: the original from the table or the derived field?</description></item><item><title>Comparing SQL schemas</title><link>/2015/07/12/comparing-sql-schemas/</link><pubDate>Sun, 12 Jul 2015 00:00:00 +0000</pubDate><guid>/2015/07/12/comparing-sql-schemas/</guid><description>During development it’s common to get your dev database out of sync with the one in production. Sometimes it’s due to an additional column in development you added before realizing it wasn&amp;rsquo;t necessary and other times it’s just creating a few temporary tables on production that you forget to drop. In both cases it’s useful to reconcile the schema differences every once in a while to keep your database in a clean state.</description></item><item><title>Ambiguous SQL queries</title><link>/2015/06/27/ambiguous-sql-queries/</link><pubDate>Sat, 27 Jun 2015 00:00:00 +0000</pubDate><guid>/2015/06/27/ambiguous-sql-queries/</guid><description>One of the best habits to develop when working with SQL is to always refer to fields through an alias. Numerous times I decided to just take a shortcut and ended up regretting it later. Even if you’ve tested your query to make sure it works there’s no guarantee that a future change to a table schema won’t break it.
Let’s say you have the following two tables - with items.</description></item><item><title>A MySQL “GROUP BY” nuance</title><link>/2015/06/09/a-mysql-group-by-nuance/</link><pubDate>Tue, 09 Jun 2015 00:00:00 +0000</pubDate><guid>/2015/06/09/a-mysql-group-by-nuance/</guid><description>I discovered a nuance with MySQL&amp;rsquo;s GROUP BY statement earlier today that I’ll share with the hope that others can learn from it. It’s fairly common to use a coalesce statement to handle null values while keeping the resulting field the same name. For example:
SELECT coalesce(a.user_id, b.other_user_id) as user_id, sum(s.num) as total_nums FROM table_a a LEFT JOIN table_b on a.some_id = b.some_other_id LEFT JOIN stats s on a.stat_id = s.</description></item><item><title>MySQL vs PostgreSQL sort order</title><link>/2015/02/01/mysql-vs-postgresql-sort-order/</link><pubDate>Sun, 01 Feb 2015 00:00:00 +0000</pubDate><guid>/2015/02/01/mysql-vs-postgresql-sort-order/</guid><description>At TripleLift, we have a migrations job that copies aggregate data from Redshift to MySQL so it can be accessed along the rest of the transactional data. As part of a test, I tried comparing that the data matched exactly but ran into an issue when exporting the data to select. Namely, to make the comparison as simple as possible I wanted to run the same select query in both tables and compare the results.</description></item><item><title>Normalizing a CSV file using MySQL</title><link>/2014/10/01/normalizing-a-csv-file-using-mysql/</link><pubDate>Wed, 01 Oct 2014 00:00:00 +0000</pubDate><guid>/2014/10/01/normalizing-a-csv-file-using-mysql/</guid><description>As part of my preparation for the Intro to MySQL class I decided to put together a dataset we’d be able to explore over the course of the class. While trying to think of an interesting dataset to use I remembered I had a script that scraped Yahoo’s fantasy football projections for the 2014 seasons that I used to prepare for my draft. The only issue was that the script generated a CSV file so I had to go through a series of steps to turn it into a clean, relational database.</description></item><item><title>The future of databases</title><link>/2014/07/05/the-future-of-databases/</link><pubDate>Sat, 05 Jul 2014 00:00:00 +0000</pubDate><guid>/2014/07/05/the-future-of-databases/</guid><description>A couple of weeks ago I attended a talk by Professor Michael Stonebraker. For those unfamiliar with him, he’s a database researcher responsible for PostgreSQL, Vertica, VoltDB and a dozen others. During his talk he shared his thoughts about the future of databases and what we can expect to see in the coming years. His main point is that databases are becoming more and more specialized and it will be very common for companies to run multiple types of databases that are optimized for different uses cases.</description></item><item><title>Solving coding tests in PostgreSQL</title><link>/2014/01/25/solving-coding-tests-in-postgresql/</link><pubDate>Sat, 25 Jan 2014 00:00:00 +0000</pubDate><guid>/2014/01/25/solving-coding-tests-in-postgresql/</guid><description>Most developers are familiar with the FizzBuzz code test which is a quick way to filter out developers who can’t code. At Yodle, we had our own, slightly more challenging problem. The challenge was read in a text file and then print out the frequency each word appears in descending order. It’s more complicated than FizzBuzz but it assesses a variety of skills. The solution needs to do the following:</description></item><item><title>Using the information_schema.columns table</title><link>/2013/12/15/using-the-information_schema.columns-table/</link><pubDate>Sun, 15 Dec 2013 00:00:00 +0000</pubDate><guid>/2013/12/15/using-the-information_schema.columns-table/</guid><description>Something that’s been really helpful to me in understanding a MySQL database is the built in information_schema.columns table. It provides information on every column in the database and is queryable just like any other table. This makes it easy to quickly find all tables that have a particular column name or all columns that are the same data type. There have been countless times where I knew the data existed somewhere but couldn’t recall which table it was in.</description></item><item><title>RDS and R</title><link>/2013/11/15/rds-and-r/</link><pubDate>Fri, 15 Nov 2013 00:00:00 +0000</pubDate><guid>/2013/11/15/rds-and-r/</guid><description>In my quest to replace Excel with R I’ve been spending the past week trying to do everything in R. It hasn’t been that easy with many things taking longer due to me having to reference the R docs but one thing that’s been great so far is being able to quickly run a query on Amazon’s RDS and pull data into a data frame for quick analysis. Being able to wrap this into a reusable function makes things even better.</description></item></channel></rss>